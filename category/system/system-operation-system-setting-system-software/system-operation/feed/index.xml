<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>System Operation (系统操作) &#8211; Eternal Center</title>
	<atom:link href="https://eternalcenter-jun-2022.github.io/category/system/system-operation-system-setting-system-software/system-operation/feed/" rel="self" type="application/rss+xml" />
	<link>https://eternalcenter-jun-2022.github.io/</link>
	<description></description>
	<lastBuildDate>Sun, 26 Jun 2022 10:33:28 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>[内容] Linux 命令 expr （截取字符串、计算字符串长度和数值运算）</title>
		<link>https://eternalcenter-jun-2022.github.io/expr/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 26 Jun 2022 10:33:09 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Basic (基础)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=26178</guid>

					<description><![CDATA[案例一：计算字符串长度 （补充：这里以计算字符串 eternalcenter.com 的长度为例） 案例二：截取字符串 （补充：这里以计算字符串 eternalcenter.com 的第 1 个字符到第 13 个字符串为例） 案例三：显示某字符在某字符串中第 1 次出现的位置 （补充：这里以显示 r 字符在字符串 eternalcenter.com 中第 1 次出现的位置为例） 案例四：数值运算 4.1 案例一：加法 （补充：这里以 1 加 1 等于 2 为例） 4.2 案例二：减法 （补充：这里以 2 减 1 等于 1 为例） 4.3 案例三：乘法 （补充：这里以 3 乘以 3 等于 9 为例） （注意：expr 使用乘法时必须要使用反义符号 “\”） 4.4 案例四：除法 &#8230; <p class="link-more"><a href="https://eternalcenter-jun-2022.github.io/expr/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Linux 命令 expr （截取字符串、计算字符串长度和数值运算）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h3>案例一：计算字符串长度</h3>



<pre class="wp-block-code"><code># expr length 'eternalcenter.com'
17</code></pre>



<p>（补充：这里以计算字符串 eternalcenter.com 的长度为例）</p>



<h3>案例二：截取字符串</h3>



<pre class="wp-block-code"><code># expr substr "eternalcenter.com" 1 13
expr substr "eternalcenter.com" 1 13</code></pre>



<p>（补充：这里以计算字符串 eternalcenter.com 的第 1 个字符到第 13 个字符串为例）</p>



<h3>案例三：显示某字符在某字符串中第 1 次出现的位置</h3>



<pre class="wp-block-code"><code># expr index eternalcenter.com r
4</code></pre>



<p>（补充：这里以显示 r 字符在字符串 eternalcenter.com 中第 1 次出现的位置为例）</p>



<h3>案例四：数值运算</h3>



<h4>4.1 案例一：加法</h4>



<pre class="wp-block-code"><code># expr 1 + 1
2</code></pre>



<p>（补充：这里以 1 加 1 等于 2 为例）</p>



<h4>4.2 案例二：减法</h4>



<pre class="wp-block-code"><code># expr 2 - 1
1</code></pre>



<p>（补充：这里以 2 减 1 等于 1 为例）</p>



<h4>4.3 案例三：乘法</h4>



<pre class="wp-block-code"><code># expr 3 \* 3
9</code></pre>



<p>（补充：这里以 3 乘以 3 等于 9 为例）</p>



<p>（注意：expr 使用乘法时必须要使用反义符号 “\”）</p>



<h4>4.4 案例四：除法</h4>



<pre class="wp-block-code"><code># expr 9 / 3 / 3
1</code></pre>



<p>（补充：这里以 9 除以 3 再除以 3 为等于 1 为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Linux tr 命令 （内容替换）</title>
		<link>https://eternalcenter-jun-2022.github.io/tr/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 24 Jun 2022 13:58:41 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Basic (基础)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System File (系统文件)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=26148</guid>

					<description><![CDATA[内容一：tr 命令的简介 1.1 tr 命令的格式 1.2 tr 命令的原理 将 &#60;section 1&#62; 里的内容替换成 &#60;section 2&#62; 里的内容 内容二：tr 命令的选项 1) -c 或者 &#8211;complement 改变除了某内容外的所有内容2) -d 或者 &#8211;delete 删除某内容3) -s 或者 &#8211;squeeze-repeats 将相临重复的某个字符缩减成 1 个4) -t 或者 &#8211;truncate-set1 将 &#60;section 1&#62; 里的内容缩减成和 &#60;section 2&#62; 里的内容一样长 内容三：tr 命令的参数 1) \ 反斜杠2) \b 退格3) \f 换页4) \n 换行5) \r 回车6) &#8230; <p class="link-more"><a href="https://eternalcenter-jun-2022.github.io/tr/" class="more-link">Continue reading<span class="screen-reader-text"> "Linux tr 命令 （内容替换）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h3>内容一：tr 命令的简介</h3>



<h4>1.1 tr 命令的格式</h4>



<pre class="wp-block-code"><code># tr &lt;option&gt; &lt;section 1&gt; &lt;sectiong 2&gt;</code></pre>



<h4>1.2 tr 命令的原理</h4>



<p>将 &lt;section 1&gt; 里的内容替换成 &lt;section 2&gt; 里的内容</p>



<h3>内容二：tr 命令的选项</h3>



<p>1) -c 或者 &#8211;complement 改变除了某内容外的所有内容<br>2) -d 或者 &#8211;delete 删除某内容<br>3) -s 或者 &#8211;squeeze-repeats 将相临重复的某个字符缩减成 1 个<br>4) -t 或者 &#8211;truncate-set1 将 &lt;section 1&gt; 里的内容缩减成和 &lt;section 2&gt; 里的内容一样长</p>



<h3>内容三：tr 命令的参数</h3>



<p>1) \ 反斜杠<br>2) \b 退格<br>3) \f 换页<br>4) \n 换行<br>5) \r 回车<br>6) \t 水平制表符<br>7) \v 垂直制表符<br>8) &lt;character 1&gt;-&lt;character 2&gt; 从某个字符到另 1 个字符，例如：a-z、a-Z、0-9<br>9) [&lt;character&gt;*] 在 &lt;section 2&gt; 中可用，&lt;character&gt; 会复制得和 &lt;section 1&gt; 中一样长<br><em>10) </em>[&lt;character&gt;*&lt;frequency&gt;] 将 &lt;character&gt; 复制 &lt;frequency&gt; 次，若以 0 开头，则视为八进制<br>11 [:alnum:] 所有字母和数字<br>12 [:alpha:] 所有字母<br>13 [:blank:] 所有呈水平排列的空白字符<br>14 [:cntrl:] 所有控制字符<br>15 [:digit:] 所有数字<br>16 [:graph:] 所有可打印字符，但不包括空格<br>17 [:lower:] 所有小写字母<br>18 [:print:] 所有可打印字符，包括空格<br>19 [:punct:] 所有标点字符<br>20 [:space:] 所有呈水平或垂直排列的空白字符<br>21 [:upper:] 所有大写字母<br>22 [:xdigit:] 所有十六进制数<br>23 [=字符=] 所有和指定字符相等的字符</p>



<h3>内容三：tr 命令的案例</h3>



<h4>3.1 案例一：替换某内容外的所有内容</h4>



<pre class="wp-block-code"><code># echo 'zmyb' | tr -c zmy a
zmyaa</code></pre>



<p>（补充：这里以将内容 zmyb 中 zmy 以外的内容替换成内容 a 为例）</p>



<p>（注意：zmyb 后面还有一个结尾符号，所以结果会多 1 个内容 a）</p>



<h4>3.2 案例二：删除某内容</h4>



<pre class="wp-block-code"><code># echo 'zmy' | tr -d m
zy</code></pre>



<p>（补充：这里以删除内容 zmy 中的内容 m 为例）</p>



<h4>3.3 案例三：将相临重复的某个字符缩减成 1 个</h4>



<pre class="wp-block-code"><code># echo zmmy | tr -s m
zmy</code></pre>



<p>（补充：这里以将内容 zmmy 中多个字符 m 压缩成 1 个为例）</p>



<h4>3.4 案例四：替换字符，并将要匹配的内容缩减成和要替换的内容一样长</h4>



<p>如果是正常情况：</p>



<pre class="wp-block-code"><code>zhumingyu@laptop:~/Test&gt; echo abeabe | tr ab c
ccecce</code></pre>



<p>（补充：这里以将内容 abeabe 中的内容 ab 替换成内容 c 为例）</p>



<p>如果是缩减的情况</p>



<pre class="wp-block-code"><code>zhumingyu@laptop:~/Test&gt; echo abeabe | tr -t ab c
cbecbe</code></pre>



<p>（补充：这里以将内容 abeabe 中的内容 a 替换成内容 c 为例）</p>



<p>（注意：这里 tr -t ab c 中内容 c 是 1 个字符，所以内容 ab 会被压缩成 1 个字符 a）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 lsof （显示进程）</title>
		<link>https://eternalcenter-jun-2022.github.io/lsof/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 23 Jun 2022 10:06:50 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Directory (系统目录)]]></category>
		<category><![CDATA[System File (系统文件)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Storage (系统存储)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<category><![CDATA[System User (系统用户)]]></category>
		<category><![CDATA[System User & System Privilege (系统用户 & 系统权限)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=26135</guid>

					<description><![CDATA[内容一：lsof 命令输出结果 内容二：lsof 命令输出结果简介 1) COMMAND 进程名2) PID （Process Id） PID 号3) USER 用户4) FD 文件描述信息（补充：cwd 代表当前目录，txt 代表 txt 文件，rtd 代表 root 目录，mem 代表内存映射文件）5) TYPE 文件类型（补充：DIR 代表当前目录，REG 代表普通文件，CHR 代表字符，a_inode 代表 Inode 文件，FIFO 代表管道或者 socket文件，netlink 代表网络，unkonwn 代表未知）6) DEVICE 设备 ID7) SIZE/OFF 进程大小8) NODE 文件的 Inode 号9) NAME 路径或链接 内容三：lsof 使用案例 3.1 案例一：显示已经被删除的文件 3.2 案例二：显示用户已打开的案例 3.2.1 显示某用户已打开的文件 &#8230; <p class="link-more"><a href="https://eternalcenter-jun-2022.github.io/lsof/" class="more-link">Continue reading<span class="screen-reader-text"> "[命令] Linux 命令 lsof （显示进程）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h3>内容一：lsof 命令输出结果</h3>



<pre class="wp-block-code"><code># lsof | more
COMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
systemd       1          root  cwd       DIR              251,1      4096          1 /
......</code></pre>



<h3>内容二：lsof 命令输出结果简介</h3>



<p>1) COMMAND 进程名<br>2) PID （Process Id） PID 号<br>3) USER 用户<br>4) FD 文件描述信息<br>（补充：cwd 代表当前目录，txt 代表 txt 文件，rtd 代表 root 目录，mem 代表内存映射文件）<br>5) TYPE 文件类型<br>（补充：DIR 代表当前目录，REG 代表普通文件，CHR 代表字符，a_inode 代表 Inode 文件，FIFO 代表管道或者 socket文件，netlink 代表网络，unkonwn 代表未知）<br>6) DEVICE 设备 ID<br>7) SIZE/OFF 进程大小<br>8) NODE 文件的 Inode 号<br>9) NAME 路径或链接</p>



<h3>内容三：lsof 使用案例</h3>



<h4>3.1 案例一：显示已经被删除的文件</h4>



<pre class="wp-block-code"><code># lsof | grep deleted</code></pre>



<h4>3.2 案例二：显示用户已打开的案例</h4>



<h5>3.2.1 显示某用户已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -u zhumingyu mingyuzhu</code></pre>



<p>（补充：这里以显示用户 zhumingyu 和 mingyuzhu 已打开的文件为例）</p>



<h5>3.2.2 不显示某用户已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -u mingyuzhu</code></pre>



<p>（补充：这里以不显示用户 mingyuzhu 已打开的文件为例）</p>



<h4>3.3 案例三：显示进程已打开的文件</h4>



<h5>3.3.1 显示某进程已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -p 1024</code></pre>



<p>（补充：这里以显示 PID 号是 1024 已打开的文件为例）</p>



<h5>3.3.2 不显示某进程已打开的所有文件</h5>



<pre class="wp-block-code"><code># lsof -p ^1024</code></pre>



<p>（补充：这里以不显示 PID 号是 1024 已打开的文件为例）</p>



<h5>3.3.3 显示某几个进程已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -p 1,2,3</code></pre>



<p>（补充：这里以显示 PID 号是 1、2 和 3 已打开的文件为例）</p>



<h4>3.4 案例四：显示已打开的网络文件</h4>



<h5>3.4.1 显示所有已打开的网络文件</h5>



<pre class="wp-block-code"><code># lsof -i</code></pre>



<h5>3.4.2 显示所有 IPv4 协议已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i 4</code></pre>



<h5>3.4.3 显示所有 IPv6 协议已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i 6</code></pre>



<h5>3.4.4 显示所有 TCP 协议已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i TCP</code></pre>



<h5>3.4.5 显示所有 TCP 协议已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i UDP</code></pre>



<h5>3.4.6 显示某个 TCP 端口或者 UDP 端口已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i:22</code></pre>



<p>（补充：这里以显示 TCP 或者 UPD 的 22 端口已打开的文件为例）</p>



<h5>3.4.7 显示某个 TCP 端口已打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i TCP:22</code></pre>



<p>（补充：这里以显示 TCP 的 22 端口已打开的文件为例）</p>



<h5>3.4.8 显示某几个 TCP 端口打开的文件</h5>



<pre class="wp-block-code"><code># lsof -i TCP:1-1024</code></pre>



<p>（补充：这里以显示 TCP 的 1 端口到 1024 端口打开的文件为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 dir （显示文件或目录）</title>
		<link>https://eternalcenter-jun-2022.github.io/dir/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 22 Jun 2022 09:34:11 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=26098</guid>

					<description><![CDATA[内容一：dir 命令的格式 内容二：dir 命令的选项 1) -a 或者 &#8211;all 显示隐藏文件和隐藏目录2) -A 或者 &#8211;almost-all 显示隐藏文件和隐藏目录，但是不显示当前目录 . 和上一级目录 ..3) -h 或者 &#8211;human-readable 以方便人类阅读的方式显示4) -l 显示文件或目录的详细信息5) -L 显示链接时现时链接指向的文件或目录而不是显示链接本身6) -g 显示文件或目录的详细信息，但是不显示所属主7) -G 显示文件或目录的详细信息，但是不显示所属组8) -r 或者 &#8211;reverse 排序时颠倒顺序9) -R 显示递归的子目录10) -S 按照大小进行排序11) -t 按照修改时间进行排序12) -x 按列进行显示13) -X 按后缀名的字母顺序进行排序]]></description>
										<content:encoded><![CDATA[
<h3>内容一：dir 命令的格式</h3>



<pre class="wp-block-code"><code># dir &lt;option&gt; &lt;file or directory&gt;</code></pre>



<h3>内容二：dir 命令的选项</h3>



<p>1) -a 或者 &#8211;all 显示隐藏文件和隐藏目录<br>2) -A 或者 &#8211;almost-all 显示隐藏文件和隐藏目录，但是不显示当前目录 . 和上一级目录 ..<br>3) -h 或者 &#8211;human-readable 以方便人类阅读的方式显示<br>4) -l 显示文件或目录的详细信息<br>5) -L 显示链接时现时链接指向的文件或目录而不是显示链接本身<br>6) -g 显示文件或目录的详细信息，但是不显示所属主<br>7) -G 显示文件或目录的详细信息，但是不显示所属组<br>8) -r 或者 &#8211;reverse 排序时颠倒顺序<br>9) -R 显示递归的子目录<br>10) -S 按照大小进行排序<br>11) -t 按照修改时间进行排序<br>12) -x 按列进行显示<br>13) -X 按后缀名的字母顺序进行排序</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 系统 UUID 的显示 （主板 UUID）</title>
		<link>https://eternalcenter-jun-2022.github.io/uuid/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 22 Jun 2022 08:30:55 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Hardware (系统硬件)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=26096</guid>

					<description><![CDATA[内容一：系统 UUID 1) UUID 全名 Universally Unique Identifier，即通用唯一识别码2) 系统 UUID 是主板产品的 UUID 内容二：系统 UUID 的显示 如果是虚拟机： 如果是虚拟机或物理机：]]></description>
										<content:encoded><![CDATA[
<h3>内容一：系统 UUID</h3>



<p>1) UUID 全名 Universally Unique Identifier，即通用唯一识别码<br>2) 系统 UUID 是主板产品的 UUID</p>



<h3>内容二：系统 UUID 的显示</h3>



<p>如果是虚拟机：</p>



<pre class="wp-block-code"><code># cat /sys/devices/virtual/dmi/id/product_uuid</code></pre>



<p>如果是虚拟机或物理机：</p>



<pre class="wp-block-code"><code># dmidecode -s system-uuid</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 数值计算</title>
		<link>https://eternalcenter-jun-2022.github.io/numerical-calculations/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Mon, 20 Jun 2022 14:36:27 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Basic (基础)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=25907</guid>

					<description><![CDATA[内容一：数值计算符号 1) + ，加法2) – ，减法3) * ，乘法4) / ，除法5) % ，求余 内容二：数值计算的方法 2.1 方法一：使用 expr 命令 或者： 或者： （补充：这里以 1 加 2 等于 3 为例） 2.2 方法二：使用 let 命令 （补充：这里以 2 除以 1 等于 2 为例） 2.3 方法三：使用双括号 (()) （补充：这里以 1 乘以 2 等于 2 为例）]]></description>
										<content:encoded><![CDATA[
<h3>内容一：数值计算符号</h3>



<p>1) + ，加法<br>2) – ，减法<br>3) * ，乘法<br>4) / ，除法<br>5) % ，求余</p>



<h3>内容二：数值计算的方法</h3>



<h4>2.1 方法一：使用 expr 命令</h4>



<pre class="wp-block-code"><code># a=1
# b=2
# c=`expr $a + $b`
# echo $c
3</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># a=1
# b=2
# c=$(expr $a + $b)
# echo $c
3</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># a=1
# b=2
# c=$&#91;`expr $a + $b`]
# echo $c
3</code></pre>



<p>（补充：这里以 1 加 2 等于 3 为例）</p>



<h4>2.2 方法二：使用 let 命令</h4>



<pre class="wp-block-code"><code># a=1
# b=2
# let c=b/c
# echo $c
2</code></pre>



<p>（补充：这里以 2 除以 1 等于 2 为例）</p>



<h4>2.3 方法三：使用双括号 (())</h4>



<pre class="wp-block-code"><code># a=1
# b=2
# c=$(($a * $b))
# echo $c
2</code></pre>



<p>（补充：这里以 1 乘以 2 等于 2 为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 显示可以无密码登陆系统的用户 （以 1 行的形式显示）</title>
		<link>https://eternalcenter-jun-2022.github.io/shell-login-check/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 11 Jun 2022 13:33:07 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System User (系统用户)]]></category>
		<category><![CDATA[System User & System Privilege (系统用户 & 系统权限)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23846</guid>

					<description><![CDATA[介绍 作者：朱明宇名称：显示可以登陆系统的用户 （以 1 行到形式显示）作用：显示可以登陆系统的用户 （以 1 行到形式显示） 使用方法：1. 给此脚本添加执行权限2. 执行此脚本 脚本]]></description>
										<content:encoded><![CDATA[
<h2>介绍</h2>



<p>作者：朱明宇<br>名称：显示可以登陆系统的用户 （以 1 行到形式显示）<br>作用：显示可以登陆系统的用户 （以 1 行到形式显示）</p>



<p>使用方法：<br>1. 给此脚本添加执行权限<br>2. 执行此脚本</p>



<h2>脚本</h2>



<pre class="wp-block-code"><code>#!/bin/bash

userlist=
n=`cat /etc/passwd | wc -l`
i=1

while &#91; $i -le $n ]
do
	line=`sed -n "$&#91;i]p" /etc/passwd`
	echo $line | egrep "nologin$|false$" &amp;&gt; /dev/null
	if &#91; $? -ne 0 ];then
                userlist="$userlist `echo $line | awk -F: '{print $1}'`"
	fi
	let i++
done

echo $userlist</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[排错] 解决 Linux 执行 crontab -e 命令时报错 “You (&#8230;&#8230;) are not allowed to use this program (crontab)”</title>
		<link>https://eternalcenter-jun-2022.github.io/debug-you-are-not-allowed-to-use-this-program-crontab/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 10 Jun 2022 10:07:51 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System File Security (系统文件安全)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Port Security (系统端口安全)]]></category>
		<category><![CDATA[System Privilege (系统权限)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<category><![CDATA[System User (系统用户)]]></category>
		<category><![CDATA[System User & System Privilege (系统用户 & 系统权限)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23780</guid>

					<description><![CDATA[解决方法 如果在系统中没有 /etc/cron.deny 配置文件，在 /etc/cron.allow 配置文件中添加要使用 crontab -e 命令的用户 添加以下内容： （补充：这里以添加用户 zhumingyu 为例） 如果在系统中没有 /etc/cron.allow 配置文件，在 /etc/cron.allow 配置文件中删除要使用 crontab -e 命令的用户 删除以下内容： （补充：这里以删除用户 zhumingyu 为例）]]></description>
										<content:encoded><![CDATA[
<h2>解决方法</h2>



<p>如果在系统中没有 /etc/cron.deny 配置文件，在 /etc/cron.allow 配置文件中添加要使用 crontab -e 命令的用户</p>



<pre class="wp-block-code"><code># vim /etc/cron.allow</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
zhumingyu</code></pre>



<p>（补充：这里以添加用户 zhumingyu 为例）</p>



<p>如果在系统中没有 /etc/cron.allow 配置文件，在 /etc/cron.allow 配置文件中删除要使用 crontab -e 命令的用户</p>



<pre class="wp-block-code"><code># vim /etc/cron.allow</code></pre>



<p>删除以下内容：</p>



<pre class="wp-block-code"><code>......
zhumingyu
......</code></pre>



<p>（补充：这里以删除用户 zhumingyu 为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 某个所属组里有哪些用户的显示</title>
		<link>https://eternalcenter-jun-2022.github.io/group-display/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 08 Jun 2022 02:50:05 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System File (系统文件)]]></category>
		<category><![CDATA[System File Security (系统文件安全)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Privilege (系统权限)]]></category>
		<category><![CDATA[System Privilege Security (系统权限安全)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Storage (系统存储)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<category><![CDATA[System User (系统用户)]]></category>
		<category><![CDATA[System User & System Privilege (系统用户 & 系统权限)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23715</guid>

					<description><![CDATA[方法一：通过 /etc/group 配置文件显示某个附属所属组里有哪些用户 （注意：此方法并不能显示出把这些所属组当作主要所属组的用户） 方法二：通过 /etc/passwd 配置文件和 id 命令等显示主要所属组和附属所属组 （补充：可以通过肉眼比对此命令的输出结果来判断其主要所属组和附属所属组）]]></description>
										<content:encoded><![CDATA[
<h3>方法一：通过 /etc/group 配置文件显示某个附属所属组里有哪些用户</h3>



<pre class="wp-block-code"><code># cat /etc/group</code></pre>



<p>（注意：此方法并不能显示出把这些所属组当作主要所属组的用户）</p>



<h3>方法二：通过 /etc/passwd 配置文件和 id 命令等显示主要所属组和附属所属组</h3>



<pre class="wp-block-code"><code># for i in `cat /etc/passwd | egrep -v "nologin$|false$|half|sync|shutdown|halt" | awk -F: '{print $1}'`; do id $i; done | sort -k2</code></pre>



<p>（补充：可以通过肉眼比对此命令的输出结果来判断其主要所属组和附属所属组）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 用户登陆记录的显示</title>
		<link>https://eternalcenter-jun-2022.github.io/login-login-display/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 08:28:00 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Log (系统日志)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Security Log (系统安全日志)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23713</guid>

					<description><![CDATA[方法一：使用 last 命令 方法二：查看系统日志 如果是 openSUSE &#38; SLE 将以下内容： （注意：必须在 /etc/ssh/sshd_config 配置文档里设置了 LogLevel INFO 参数和 SyslogFacility AUTH 参数以后此方法才会有效） 如果是 Rocky Linux &#38; CentOS Linux &#38; RHEL： 或者： （注意：必须在 /etc/ssh/sshd_config 配置文档里设置了 LogLevel INFO 参数和 SyslogFacility AUTH 参数以后此方法才会有效）]]></description>
										<content:encoded><![CDATA[
<h3>方法一：使用 last 命令</h3>



<pre class="wp-block-code"><code># last | grep pts</code></pre>



<h3>方法二：查看系统日志</h3>



<p>如果是 openSUSE &amp; SLE 将以下内容：</p>



<pre class="wp-block-code"><code># cat /var/log/messages | grep systemd-logind</code></pre>



<p>（注意：必须在 /etc/ssh/sshd_config 配置文档里设置了 LogLevel INFO 参数和 SyslogFacility AUTH 参数以后此方法才会有效）</p>



<p>如果是 Rocky Linux &amp; CentOS Linux &amp; RHEL：</p>



<pre class="wp-block-code"><code># cat /var/log/secure | grep systemd-logind</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># cat /var/log/messages | grep systemd-logind</code></pre>



<p>（注意：必须在 /etc/ssh/sshd_config 配置文档里设置了 LogLevel INFO 参数和 SyslogFacility AUTH 参数以后此方法才会有效）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 批量检测指定用户是否可以登录本地服务器</title>
		<link>https://eternalcenter-jun-2022.github.io/shell-user-login-check/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 05 Jun 2022 16:21:49 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23696</guid>

					<description><![CDATA[介绍 作者：朱明宇名称：批量检测指定用户是否可以登录本地服务器作用：批量检测指定用户是否可以登录本地服务器 使用方法：1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：directorylist=&#8221;daemon bin sys adm uucp guest nobody lpd lp&#8221; #要被检测的用户 脚本]]></description>
										<content:encoded><![CDATA[
<h2>介绍</h2>



<p>作者：朱明宇<br>名称：批量检测指定用户是否可以登录本地服务器<br>作用：批量检测指定用户是否可以登录本地服务器</p>



<p>使用方法：<br>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>directorylist=&#8221;daemon bin sys adm uucp guest nobody lpd lp&#8221; #要被检测的用户</p>



<h2>脚本</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################

directorylist="daemon bin sys adm uucp guest nobody lpd lp"

####################### Separator ########################

directorycheck=

for i in `echo $directorylist`
do
        directorycheck="$directorycheck `cat /etc/passwd | egrep "^$i:" | egrep -v '/sbin/nologin|false|/bin/false' | awk -F: '{print $1}'`"
done

echo $directorycheck</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] RHEL 命令 sos （搜集系统信息用于 RedHat 官方技术支持进行排错）</title>
		<link>https://eternalcenter-jun-2022.github.io/sos/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 27 May 2022 06:54:22 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23645</guid>

					<description><![CDATA[案例一：搜集系统信息 （注意：正常情况下 sosr eport 的执行时间不应该超过 15 分钟） 案例二：搜集信息信息并显示扫描过程 （例如：扫描了哪些插件） （注意：正常情况下 sos report 的执行时间不应该超过 15 分钟） 案例三：搜集系统信息并跳过某 1 个插件 （注意：正常情况下 sos report 的执行时间不应该超过 15 分钟）]]></description>
										<content:encoded><![CDATA[
<h3>案例一：搜集系统信息</h3>



<pre class="wp-block-code"><code># sos report</code></pre>



<p>（注意：正常情况下 sosr eport 的执行时间不应该超过 15 分钟）</p>



<h3>案例二：搜集信息信息并显示扫描过程 （例如：扫描了哪些插件）</h3>



<pre class="wp-block-code"><code># sos report -vvv</code></pre>



<p>（注意：正常情况下 sos report 的执行时间不应该超过 15 分钟）</p>



<h3>案例三：搜集系统信息并跳过某 1 个插件</h3>



<pre class="wp-block-code"><code># sos report --skip-plugin &lt;plugin&gt;</code></pre>



<p>（注意：正常情况下 sos report 的执行时间不应该超过 15 分钟）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] RHEL 命令 sosreport （搜集系统信息用于 RedHat 官方技术支持进行排错）</title>
		<link>https://eternalcenter-jun-2022.github.io/sosreport/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 27 May 2022 06:51:44 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23642</guid>

					<description><![CDATA[案例一：搜集系统信息 （注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟） 案例二：搜集信息信息并显示扫描过程 （例如：扫描了哪些插件） （注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟） 案例三：搜集系统信息并跳过某 1 个插件 （注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟）]]></description>
										<content:encoded><![CDATA[
<h3>案例一：搜集系统信息</h3>



<pre class="wp-block-code"><code># sosreport</code></pre>



<p>（注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟）</p>



<h3>案例二：搜集信息信息并显示扫描过程 （例如：扫描了哪些插件）</h3>



<pre class="wp-block-code"><code># sosreport -vvv</code></pre>



<p>（注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟）</p>



<h3>案例三：搜集系统信息并跳过某 1 个插件</h3>



<pre class="wp-block-code"><code># sosreport --skip-plugin &lt;plugin&gt;</code></pre>



<p>（注意：正常情况下 sosreport 的执行时间不应该超过 15 分钟）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 time （显示其它命令所需执行时间）</title>
		<link>https://eternalcenter-jun-2022.github.io/time/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 27 May 2022 06:44:55 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23640</guid>

					<description><![CDATA[（补充：这里以显示 sosreport 命令所需执行时间为例）]]></description>
										<content:encoded><![CDATA[
<pre class="wp-block-code"><code># time sosreport</code></pre>



<p>（补充：这里以显示 sosreport 命令所需执行时间为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[排错] 解决 Linux 运行 source ~/.bashrc 时报错 “if: Expression Syntax. then: Command not found.”</title>
		<link>https://eternalcenter-jun-2022.github.io/debug-if-expression-syntax-then-command-not-found/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 27 May 2022 06:20:24 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23635</guid>

					<description><![CDATA[报错代码 分析 此时终端没有使用 bash 解释器，而是使用了简化版 sh 解释器 解决方法]]></description>
										<content:encoded><![CDATA[
<h2>报错代码</h2>



<pre class="wp-block-code"><code>if: Expression Syntax. then: Command not found.</code></pre>



<h2>分析</h2>



<p>此时终端没有使用 bash 解释器，而是使用了简化版 sh 解释器</p>



<h2>解决方法</h2>



<pre class="wp-block-code"><code>&gt; exec bash ; source ~/.bashrc</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 测试 SFTP 服务</title>
		<link>https://eternalcenter-jun-2022.github.io/shell-sftp-test/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 14 May 2022 14:11:28 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[SFTP]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<category><![CDATA[Storage Services (存储服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23553</guid>

					<description><![CDATA[介绍 作者：朱明宇名称：测试 SFTP 服务作用：测试 SFTP 服务 使用方法： 1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：IP=10.0.0.8 #要测试 SFTP 的服务器 IP 地址 注意：此脚本执行前必须要先保证执行脚本的主机能无秘钥远程需要测试 SFTP 服务的服务器 脚本]]></description>
										<content:encoded><![CDATA[
<h2>介绍</h2>



<p>作者：朱明宇<br>名称：测试 SFTP 服务<br>作用：测试 SFTP 服务</p>



<p>使用方法：</p>



<p>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>IP=10.0.0.8 #要测试 SFTP 的服务器 IP 地址 </p>



<p>注意：此脚本执行前必须要先保证执行脚本的主机能无秘钥远程需要测试 SFTP 服务的服务器</p>



<h2>脚本</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################
IP=10.0.0.8
####################### Separator ########################

set timeout 3

rpm -q expect &amp;&gt; /dev/null
if &#91; $? -ne 0 ];then
        echo "Expect needs to be installed first"
fi

expect &lt;&lt; EOF
spawn sftp $IP
expect "sftp&gt;"                                   {send "cd /tmp\r" } 
expect "sftp&gt;"                                   {send "ls -l\r"}
expect "sftp&gt;"                                   {send "quit\r"}
expect "&gt;"                                       {send "\r"}
EOF</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux 救援模式软件的安装</title>
		<link>https://eternalcenter-jun-2022.github.io/resuce-rpm/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 29 Apr 2022 12:29:07 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23378</guid>

					<description><![CDATA[步骤一：挂载官方镜像 （步骤略） 步骤二：登录拯救模式 2.1 进入拯救模式 （步骤略） 2.2 登录拯救模式 步骤三：在救援模式确定系统的根目录分区 （步骤略） （补充：1) 物理分区可以使用 lsblk 命令、fdisk -l 或 cat /proc/partitions 命令辅助确定2) 逻辑分区还可以可以使用 pvs 命令、lvs 命令或 lvdisplay 命令辅助确定） 步骤四：在救援模式将系统的分区挂载到救援模式的 /mnt 目录 4.1 在救援模式将系统的根分区挂载到救援模式的 /mnt 目录 （补充：1) 如果是物理分区，系统的根分区就在救援模式的 /dev/ 目录里，例如救援模式的 /dev/sda12) 如果是逻辑分区，Rocky Linux &#38; RHEL 的系统根分区就是救援模式里的 /dev/&#60;volume group&#62;/&#60;logical volume&#62; 例如救援模式里的 /dev/vg/lv，openSUSE &#38; SUSE 的系统根分区就是救援模式里的 /dev/mapper/&#60;volume group&#62;-&#60;logical volume&#62; 例如救援模式里的 /dev/mapper/vg-lv） &#8230; <p class="link-more"><a href="https://eternalcenter-jun-2022.github.io/resuce-rpm/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Linux 救援模式软件的安装"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h3>步骤一：挂载官方镜像</h3>



<p>（步骤略）</p>



<h3>步骤二：登录拯救模式</h3>



<h4>2.1 进入拯救模式</h4>



<p>（步骤略）</p>



<h4>2.2 登录拯救模式</h4>



<pre class="wp-block-code"><code>rescue login:root</code></pre>



<h3>步骤三：在救援模式确定系统的根目录分区</h3>



<p>（步骤略）</p>



<p>（<br>补充：<br>1) 物理分区可以使用 lsblk 命令、fdisk -l 或 cat /proc/partitions 命令辅助确定<br>2) 逻辑分区还可以可以使用 pvs 命令、lvs 命令或 lvdisplay 命令辅助确定<br>）</p>



<h3>步骤四：在救援模式将系统的分区挂载到救援模式的 /mnt 目录</h3>



<h4>4.1 在救援模式将系统的根分区挂载到救援模式的 /mnt 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount &lt;root spartition&gt; /mnt</code></pre>



<p>（<br>补充：<br>1) 如果是物理分区，系统的根分区就在救援模式的 /dev/ 目录里，例如救援模式的 /dev/sda1<br>2) 如果是逻辑分区，Rocky Linux &amp; RHEL 的系统根分区就是救援模式里的 /dev/&lt;volume group&gt;/&lt;logical volume&gt; 例如救援模式里的 /dev/vg/lv，openSUSE &amp; SUSE 的系统根分区就是救援模式里的 /dev/mapper/&lt;volume group&gt;-&lt;logical volume&gt; 例如救援模式里的 /dev/mapper/vg-lv<br>）</p>



<h4>4.2 在救援模式将救援模式的 /dev 目录关联到救援模式的 /mnt/dev 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /dev /mnt/dev</code></pre>



<p>（<br>补充：<br>1) 此时所有对救援模式的 /mnt/dev 目录的访问都会变成对救援模式的 /dev 目录的访问<br>2) 步骤 4.2、步骤 4.3 和步骤 4.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>4.3 在救援模式将救援模式的 /proc 目录关联到救援模式的 /mnt/proc 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /proc /mnt/proc</code></pre>



<p>（<br>1) 补充：此时所有对救援模式的 /mnt/proc 目录的访问都会变成对救援模式的 /proc 目录的访问<br>2) 步骤 4.2、步骤 4.3 和步骤 4.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>4.4 在救援模式将救援模式的 /sys 目录关联到救援模式的 /mnt/sys 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /sys /mnt/sys</code></pre>



<p>（<br>1) 补充：此时所有对救援模式的 /mnt/sys 目录的访问都会变成对救援模式的 /sys 目录的访问<br>2) 步骤 4.2、步骤 4.3 和步骤 4.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>4.5 在救援模式将救援模式的 /run 目录关联到救援模式的 /mnt/run 目录 （选做）</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /run /mnt/run</code></pre>



<p>（补充：此时所有对救援模式的 /mnt/run 目录的访问都会变成对救援模式的 /run 目录的访问）</p>



<h3>步骤五：将当前的根目录从救援模式的根目录切换到系统的根目录</h3>



<h4>5.1 将当前的根目录从救援模式的根目录切换到系统的根目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # chroot /mnt</code></pre>



<p>（补充：这里以 /mnt 作为系统根目录为例）</p>



<h4>5.2 在系统模式挂载所有需要开机自动挂载的目录</h4>



<pre class="wp-block-code"><code>bash-4.3# mount -a</code></pre>



<h4>5.3 在系统模式确认当前根目录下的目录</h4>



<pre class="wp-block-code"><code>bash-4.3# ls
bin boot dev home lib lib64 mnt opt proc root run sbin selinux srv sys tmp usr var</code></pre>



<h3>步骤六：在系统模式安装软件</h3>



<h4>6.1 在系统模式挂载官方镜像</h4>



<h5>6.1.1 在系统模式创建用于挂载镜像的 /media 目录</h5>



<pre class="wp-block-code"><code>bash-4.3# mkdir /media</code></pre>



<h5>6.1.2 在系统模式挂将官方镜像挂载到 /media 目录</h5>



<pre class="wp-block-code"><code>bash-4.3# mount /dev/dvd /media</code></pre>



<h4>6.2 在系统模式安装 rpm 软件</h4>



<h5>6.2.1 在系统模式安装拷贝 rpm 软件包到当前目录</h5>



<pre class="wp-block-code"><code>bash-4.3# cp /media/suse/x86_64/rpm-4.11.2-16.21.1.x86_64.rpm .</code></pre>



<p>（补充：这里以安装 rpm-4.11.2-16.21.1.x86_64.rpm 软件为例）</p>



<h5>6.2.2 在系统模式创建用于安装 rpm 软件的 pkg 目录</h5>



<pre class="wp-block-code"><code>bash-4.3# mkdir pkg</code></pre>



<h5>6.2.3 在系统模式进入 pkg 目录</h5>



<pre class="wp-block-code"><code>bash-4.3# cd pkg</code></pre>



<h5>6.2.4 在系统模式安装 rpm 软件</h5>



<pre class="wp-block-code"><code>bash-4.3# rpm2cpio ../rpm-4.11.2-16.21.1.x86_64.rpm | cpio -ivd</code></pre>



<p>（补充：这里以安装 rpm-4.11.2-16.21.1.x86_64.rpm 软件为例）</p>



<h5>6.2.5 在系统模式将 bin/rpm 目录拷贝到 /bin 目录</h5>



<pre class="wp-block-code"><code>bash-4.3# cp bin/rpm /bin/</code></pre>



<h1>参考文献：</h1>



<p class="has-text-align-center">https://www.suse.com/support/kb/doc/?id=000018770</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux 系统被删根 （rm -rf /*） 后锁定删根 （rm -rf /*） 用户的尝试 （系统层面）</title>
		<link>https://eternalcenter-jun-2022.github.io/rm-rf-user/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 28 Apr 2022 15:03:04 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23353</guid>

					<description><![CDATA[步骤一：系统被删根 （rm -rf /*） 后的现象总结 1) 系统无法被 ssh2) 通过 console 口登录系统在输入密码时会卡住3) 尝试将当前根目录从救援模式的根目录切换到系统的根目录时会报错 “chroot: failed to run command #/bin/bash#: No such file or directory”4) 重启系统后无法进入系统，并提示：/grub2/i386-pc/normoal.mod not found gpt5）在救援模式显示 /boot 目录里的文件时，可能会发现此目录下只有 grub2 目录，而此 grub2 目录里也是空的6) 在救援模式显示 /bin 目录时，会显示并无此目录7) 在救援模式显示 /etc 目录里的文件时，可能会发现此目录下只有 lvm 文件 步骤二：挂载官方镜像 （步骤略） 步骤三：登录拯救模式 3.1 进入拯救模式 （步骤略） 3.2 登录拯救模式 步骤四：在救援模式确定系统的根目录分区 （步骤略） （补充：1) 物理分区可以使用 lsblk 命令、fdisk &#8230; <p class="link-more"><a href="https://eternalcenter-jun-2022.github.io/rm-rf-user/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Linux 系统被删根 （rm -rf /*） 后锁定删根 （rm -rf /*） 用户的尝试 （系统层面）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h3>步骤一：系统被删根 （rm -rf /*） 后的现象总结</h3>



<p>1) 系统无法被 ssh<br>2) 通过 console 口登录系统在输入密码时会卡住<br>3) 尝试将当前根目录从救援模式的根目录切换到系统的根目录时会报错 “chroot: failed to run command #/bin/bash#: No such file or directory”<br>4) 重启系统后无法进入系统，并提示：/grub2/i386-pc/normoal.mod not found gpt<br>5）在救援模式显示 /boot 目录里的文件时，可能会发现此目录下只有 grub2 目录，而此 grub2 目录里也是空的<br>6) 在救援模式显示 /bin 目录时，会显示并无此目录<br>7) 在救援模式显示 /etc 目录里的文件时，可能会发现此目录下只有 lvm 文件</p>



<h3>步骤二：挂载官方镜像</h3>



<p>（步骤略）</p>



<h3>步骤三：登录拯救模式</h3>



<h4>3.1 进入拯救模式</h4>



<p>（步骤略）</p>



<h4>3.2 登录拯救模式</h4>



<pre class="wp-block-code"><code>rescue login:root</code></pre>



<h3>步骤四：在救援模式确定系统的根目录分区</h3>



<p>（步骤略）</p>



<p>（<br>补充：<br>1) 物理分区可以使用 lsblk 命令、fdisk -l 或 cat /proc/partitions 命令辅助确定<br>2) 逻辑分区还可以可以使用 pvs 命令、lvs 命令或 lvdisplay 命令辅助确定<br>）</p>



<h3>步骤五：在救援模式将系统的分区挂载到救援模式的 /mnt 目录</h3>



<h4>5.1 在救援模式将系统的根分区挂载到救援模式的 /mnt 目录</h4>



<h5>5.1.1 在救援模式将系统的根分区挂载到救援模式的 /mnt 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount &lt;root spartition&gt; /mnt</code></pre>



<p>（<br>补充：<br>1) 如果是物理分区，系统的根分区就在救援模式的 /dev/ 目录里，例如救援模式的 /dev/sda1<br>2) 如果是逻辑分区，Rocky Linux &amp; RHEL 的系统根分区就是救援模式里的 /dev/&lt;volume group&gt;/&lt;logical volume&gt; 例如救援模式里的 /dev/vg/lv，openSUSE &amp; SUSE 的系统根分区就是救援模式里的 /dev/mapper/&lt;volume group&gt;-&lt;logical volume&gt; 例如救援模式里的 /dev/mapper/vg-lv<br>）</p>



<h5>5.1.2 在救援模式确认系统的根分区已经挂载到救援模式的 /mnt 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls /mnt</code></pre>



<p>（补充：此时可以看到 /mnt 目录下有系统根目录下的各个目录，例如 /etc /root 等）</p>



<h4>5.2 在救援模式将救援模式的 /dev 目录关联到救援模式的 /mnt/dev 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /dev /mnt/dev</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --rbind /dev /mnt/dev</code></pre>



<p>（<br>补充：<br>1) 此时所有对救援模式的 /mnt/dev 目录的访问都会变成对救援模式的 /dev 目录的访问<br>2) 步骤 5.2、步骤 5.3 和步骤 5.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>5.3 在救援模式将救援模式的 /proc 目录关联到救援模式的 /mnt/proc 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /proc /mnt/proc</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --rbind /proc /mnt/proc</code></pre>



<p>（<br>补充：<br>1) 此时所有对救援模式的 /mnt/proc 目录的访问都会变成对救援模式的 /proc 目录的访问<br>2) 步骤 5.2、步骤 5.3 和步骤 5.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>5.4 在救援模式将救援模式的 /sys 目录关联到救援模式的 /mnt/sys 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /sys /mnt/sys</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --rbind /sys /mnt/sys</code></pre>



<p>（<br>补充：<br>1) 此时所有对救援模式的 /mnt/sys 目录的访问都会变成对救援模式的 /sys 目录的访问<br>2) 步骤 5.2、步骤 5.3 和步骤 5.4 也可以用以下命令代替：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # for i in proc sys dev; do mount --rbind /$i /mnt/$i ; done</code></pre>



<p>）</p>



<h4>5.5 在救援模式将救援模式的 /run 目录关联到救援模式的 /mnt/run 目录 （选做）</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount --bind /run /mnt/run</code></pre>



<p>（补充：此时所有对救援模式的 /mnt/run 目录的访问都会变成对救援模式的 /run 目录的访问）</p>



<h3>步骤六：显示系统被删根 （rm -rf /*） 后的现象</h3>



<h4>6.1 尝试将当前根目录从救援模式的根目录切换到系统的根目录时会报错 “chroot: failed to run command #/bin/bash#: No such file or directory”</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # chroot /mnt
chroot: failed to run command #/bin/bash#: No such file or directory</code></pre>



<p>（补充：这里以 /mnt 作为系统根目录为例）</p>



<p>（注意：因为在使用 rm -rf /* 命令删过根以后，/bin/bash 已经被删除，所以会报错：chroot: failed to run command #/bin/bash#: No such file or directory）</p>



<h4>6.2 在救援模式显示 /boot 目录里的文件时，会发现此目录下只有 grub2 目录，而此 grub2 目录里也是空的</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls /boot 
grub2</code></pre>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls /boot</code></pre>



<p>此步骤也可以通过以下方法实现：</p>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls -l /mounts/mp_0001/boot
total 0
......grub2</code></pre>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls -l /mounts/mp_0001/boot/grub2
total 0</code></pre>



<h4>6.3 在救援模式显示 /bin 目录时，会显示并无此目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls /mnt/bin
ls: cannot access '/mnt/bin' : No such file or directory</code></pre>



<h4>6.4 在救援模式显示 /etc 目录里的文件时，会发现此目录下只有 lvm 文件</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # ls /etc/
lvm</code></pre>



<h3>步骤七：在救援模式修复系统的 /bin 目录和里面的文件</h3>



<h4>7.1 在救援模式创建 /mnt/bin 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ # mkdir /mnt/bin</code></pre>



<h4>7.2 在救援模式挂载官方镜像</h4>



<h5>7.2.1 在救援模式创建用于挂载镜像的 /media 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # /media</code></pre>



<h5>7.2.2 在救援模式挂将官方镜像挂载到 /media 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # mount /dev/dvd /media</code></pre>



<h4>7.3 在救援模式安装 bash 软件</h4>



<h5>7.3.1 在救援模式安装拷贝 bash 软件包到当前目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # cp /media/suse/x86_64/bash-4.3-83.23.1.x86_64.rpm .</code></pre>



<p>（补充：这里以拷贝 /media/suse/x86_64/bash-4.3-83.23.1.x86_64.rpm）</p>



<h5>7.3.2 在救援模式创建用于安装 bash 软件的 bash 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # mkdir bash</code></pre>



<h5>7.3.3 在救援模式进入 bash 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ # cd bash</code></pre>



<h5>7.3.4 在救援模式安装 bash 软件</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # rpm2cpio ../bash-4.3-83.23.1.x86_64.rpm | cpio -ivd</code></pre>



<p>（补充：这里以安装 bash-4.3-83.23.1.x86_64.rpm 软件为例）</p>



<h5>7.3.5 在救援模式显示安装 bash 软件后生成的目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # ls
bin etc usr</code></pre>



<h4>7.4 在救援模式将 bin 目录下的文件拷贝到 /mnt/bin 目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # cp -rpv bin/* /mnt/bin
'bin/bash' -&gt; '/mnt/bin/bash'
'bin/sh' -&gt; '/mnt/bin/sh'</code></pre>



<h4>7.5 在救援模式拷贝 /bin/bash 文件依赖的动态链接库到 /mnt 目录下存放 /bin/bash 文件依赖的动态链接库的目录</h4>



<h5>7.5.1 在救援模式查看 /bin/bash 文件依赖的动态链接库</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # ldd /bin/bash</code></pre>



<h5>7.5.2 在救援模式在 /mnt 目录下创建存放 /bin/bash 文件依赖的动态链接库的目录</h5>



<h5>7.5.2.1 创建 lib 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # mkdir /mnt/lib</code></pre>



<h5>7.5.2.2 创建 lib64 目录</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # mkdir /mnt/lib64</code></pre>



<h5>7.5.3 在救援模式拷贝 /bin/bash 文件依赖的动态链接库到 /mnt 目录下存放 /bin/bash 文件依赖的动态链接库的目录</h5>



<h5>7.5.3.1 拷贝存放在 lib 目录的动态链接库</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # cp /lib/x86_64-linux-gnu/liblsp.so /mnt/lib
tty1:rescue:~ /bash # cp /lib/x86_64-linux-gnu/libtinfo.so.5 /mnt/lib
tty1:rescue:~ /bash # cp /lib/x86_64-linux-gnu/libd1.so.2 /mnt/lib
tty1:rescue:~ /bash # cp /lib/x86_64-linux-gnu/libc.so.6 /mnt/lib</code></pre>



<h5>7.5.3.2 拷贝存放在 lib64 目录的动态链接库</h5>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # cp /lib64/ld-linux-x86-64.so.2 /mnt/lib64</code></pre>



<h3>步骤八：将当前的根目录从救援模式的根目录切换到系统的根目录</h3>



<h4>8.1 将当前的根目录从救援模式的根目录切换到系统的根目录</h4>



<pre class="wp-block-code"><code>tty1:rescue:~ /bash # chroot /mnt</code></pre>



<p>（补充：这里以 /mnt 作为系统根目录为例）</p>



<h4>8.2 在系统模式下挂载所有需要开机自动挂载的目录</h4>



<pre class="wp-block-code"><code>bash-4.3# mount -a</code></pre>



<h4>8.3 在系统模式下确认当前根目录下的目录</h4>



<pre class="wp-block-code"><code>bash-4.3# ls
bin boot dev home lib lib64 mnt opt proc root run sbin selinux srv sys tmp usr var</code></pre>



<h3>步骤九：锁定有删根 （rm -rf /*<em>） 操作的用户 </em></h3>



<h4><em>9.1 在系统模式显示历史命令以确认有没有用户输入过 rm -rf /</em> 命令</h4>



<pre class="wp-block-code"><code>bash-4.3# history | less</code></pre>



<h4>9.2 在系统模式显示用户登录记录</h4>



<pre class="wp-block-code"><code>bash-4.3# last | less</code></pre>



<p>（补充：此时会显示最后登录系统的用户、登陆时间、且可能最后 1 个登录系统的用户无退出时间）</p>



<h4>9.3 根据步骤 9.1 和步骤 9.2 推测是哪个用户进行过删根 （rm -rf /*） 操作</h4>



<p>（步骤略）</p>



<h1>参考文献：</h1>



<p class="has-text-align-center">https://www.suse.com/support/kb/doc/?id=000018770</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] GNOME 命令 gnome-terminal （打开新的命令行终端）</title>
		<link>https://eternalcenter-jun-2022.github.io/gnome-terminal-2/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 27 Apr 2022 14:56:15 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23338</guid>

					<description><![CDATA[案例一：打开新的命令行终端，在 1 个新的窗口上运行 案例二：打开新的命令行终端，并自定义窗口的大小和位置，在 1 个新的窗口上运行 （补充：这里以打开新的命令行终端，并将终端窗口设置为宽 120，高 80，左偏移量 20，上偏移量 80 为例） 案例三：最大化打开新的命令行终端，在 1 个新的窗口上运行 案例四：全屏话化打开新的命令行终端，在 1 个新的窗口上运行 案例五：打开新的命令行终端，并设置标题，在 1 个新的窗口上运行 （补充：这里以打开新的命令行终端，并将终端窗口名命名为 Eternal Center 为例） 案例六：同时打开多个新的命令行终端，在 1 个新的窗口上运行 6.1 同时打开 2 个新的命令行终端，在新的窗口上运行 （每 1 个窗口 1 个新的命令行终端） 6.2 同时打开 4 个新的命令行终端，在新的窗口上运行 （每 1 个窗口 2 个新的命令行终端）]]></description>
										<content:encoded><![CDATA[
<h3>案例一：打开新的命令行终端，在 1 个新的窗口上运行</h3>



<pre class="wp-block-code"><code># gnome-terminal</code></pre>



<h3>案例二：打开新的命令行终端，并自定义窗口的大小和位置，在 1 个新的窗口上运行</h3>



<pre class="wp-block-code"><code># gnome-terminal --geometry=120*80+20+10</code></pre>



<p>（补充：这里以打开新的命令行终端，并将终端窗口设置为宽 120，高 80，左偏移量 20，上偏移量 80 为例）</p>



<h3>案例三：最大化打开新的命令行终端，在 1 个新的窗口上运行</h3>



<pre class="wp-block-code"><code># gnome-terminal --maximize</code></pre>



<h3>案例四：全屏话化打开新的命令行终端，在 1 个新的窗口上运行</h3>



<pre class="wp-block-code"><code># gnome-terminal --full-screen</code></pre>



<h3>案例五：打开新的命令行终端，并设置标题，在 1 个新的窗口上运行</h3>



<pre class="wp-block-code"><code># gnome-terminal --title="Eternal Center"</code></pre>



<p>（补充：这里以打开新的命令行终端，并将终端窗口名命名为 Eternal Center 为例）</p>



<h3>案例六：同时打开多个新的命令行终端，在 1 个新的窗口上运行</h3>



<h4>6.1 同时打开 2 个新的命令行终端，在新的窗口上运行 （每 1 个窗口 1 个新的命令行终端）</h4>



<pre class="wp-block-code"><code># gnome-terminal --window --window</code></pre>



<h4>6.2 同时打开 4 个新的命令行终端，在新的窗口上运行 （每 1 个窗口 2 个新的命令行终端）</h4>



<pre class="wp-block-code"><code># gnome-terminal --window --tab --window --tab</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 显示系统常用信息</title>
		<link>https://eternalcenter-jun-2022.github.io/shell-display-system-common-information/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 26 Apr 2022 16:14:48 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Directory (系统目录)]]></category>
		<category><![CDATA[System Hardware (系统硬件)]]></category>
		<category><![CDATA[System Network (系统网络)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Port Security (系统端口安全)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<category><![CDATA[System Storage (系统存储)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-jun-2022.github.io/?p=23311</guid>

					<description><![CDATA[介绍 作者：朱明宇名称：显示系统常用信息作用：显示系统常用信息 使用方法：1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：1) times=2 #显示系统常用信息的次数2) sleeptime=0.1 #大部分行与行之间显示的间隔时间 注意：部分功能需要安装了 sysstat 软件或搭建了 KVM 虚拟化平台后执行此脚本的用户能够使用 sudo virsh list 命令后才能实现 脚本]]></description>
										<content:encoded><![CDATA[
<h2>介绍</h2>



<p>作者：朱明宇<br>名称：显示系统常用信息<br>作用：显示系统常用信息</p>



<p>使用方法：<br>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>1) times=2 #显示系统常用信息的次数<br>2) sleeptime=0.1 #大部分行与行之间显示的间隔时间</p>



<p>注意：部分功能需要安装了 sysstat 软件或搭建了 KVM 虚拟化平台后执行此脚本的用户能够使用 sudo virsh list 命令后才能实现</p>



<h2>脚本</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################
times=2
sleeptime=0.1
####################### Separator ########################

nowtime=1

while (( nowtime &lt;= times))
do
        echo -e "Start Monitoring: \c"
	for i in {1..100}
	do
	        echo -e "#\c"
		sleep 0.01
        done
	echo

	sleep $sleeptime
        host=`hostname`
        echo -e "Name:\t\t\t\t\t\t \033&#91;1m$host\033&#91;0m"

        ip=`ip a s | awk '/&#91;1-2]?&#91;0-9]{0,2}\.&#91;1-2]?&#91;0-9]{0,2}/&amp;&amp;!/127.0.0.1/{print $2}' | awk -F/ '{print $1}'`
        for iip in `echo $ip`
        do
		sleep $sleeptime
                echo -e "IP Address:\t\t\t\t\t \033&#91;1m$iip\033&#91;0m"
        done

        sleep $sleeptime

        cpu=`top -bn 1 | awk -F',' '/^%Cpu/{print $4 }' | awk '{print $1}' | awk '{print 100-$1}'`
        echo -e "CPU Usage (Total):\t\t\t\t \033&#91;1m$cpu%\033&#91;0m"

        sleep $sleeptime

        mem=`free | grep Mem | awk '{print $3/$2 * 100.0}' | egrep -o "&#91;1]?&#91;0-9]{0,2}\.&#91;0-9]"`
        echo -e "Memory Usage (Total):\t\t\t\t \033&#91;1m$mem%\033&#91;0m"

	directory=`df -h | grep -v run | grep -v boot | awk '$1~/\/dev/{print $6}'`
        for idirectory in `echo $directory`
        do
                sleep $sleeptime
                directoryusage=`df -h | grep -v run | grep -v boot | awk '$1~/\/dev/{print}' | grep $idirectory$ | awk '{print $5}'`
		if &#91; $idirectory == / -o $idirectory == /ec  ];then
                        echo -e "Directory Usage ($idirectory):\t\t\t\t \033&#91;1m$directoryusage\033&#91;0m"
	        else
                        echo -e "Directory Usage ($idirectory):\t\t\t \033&#91;1m$directoryusage\033&#91;0m"
		fi
        done

	sudo -l | grep 'virsh list' &amp;&gt; /dev/null
        if &#91; $? -eq 0 ];then
	        sleep $sleeptime
	        virtual=`sudo virsh list | egrep &#91;0-9] | wc -l`
	        echo -e "Number of Virtual Machines (Total):\t\t \033&#91;1m$virtual\033&#91;0m"
        fi

        sleep $sleeptime

        user=`who | wc -l`
        echo -e "Number of User Logins (Total):\t\t\t \033&#91;1m$user\033&#91;0m"

        soft=`rpm -qa | wc -l`
        echo -e "Number of Softwares (Total):\t\t\t \033&#91;1m$soft\033&#91;0m"

        sleep $sleeptime

        port=`ss -ntulap | wc -l`
        echo -e "Number of Open Ports (Total):\t\t\t \033&#91;1m$port\033&#91;0m"

        which sar &amp;&gt; /dev/null
        if &#91; $? -eq 0 ];then
                networkcard=`ifconfig | awk -F: '/flags/&amp;&amp;!/lo/{print $1}'`
                for inetworkcard in `echo $networkcard`
                do
                        networkread="`sar -n DEV 1 1 | grep $inetworkcard | awk '/&#91;0-9]&#91;0-9]:&#91;0-9]&#91;0-9]/{print $3/1000}'` m/s"
                        networkwrite="`sar -n DEV 1 1 | grep $inetworkcard | awk '/&#91;0-9]&#91;0-9]:&#91;0-9]&#91;0-9]/{print $4/1000}'` m/s"
			echo $inetworkcard | grep eth &amp;&gt; /dev/null
			if &#91; $?  -ne 0 ];then
	                echo -e "Network Card IO ($inetworkcard):\t\t\t \033&#91;1m$networkread\033&#91;0m (Read)\t\033&#91;1m$networkwrite\033&#91;0m (Write)"
		        else
	                echo -e "Network Card IO ($inetworkcard):\t\t\t\t \033&#91;1m$networkread\033&#91;0m (Read)\t\033&#91;1m$networkwrite\033&#91;0m (Write)"
			fi
                done
        fi

        which iostat &amp;&gt; /dev/null
        if &#91; $? -eq 0 ];then
	        disk=`iostat -d -k 1 1 | awk '!/^$/&amp;&amp;!/Device/&amp;&amp;!/Linux/{print $1}'`
                for idisk in `echo $disk`
	        do
			sleep $sleeptime
		        diskread="`iostat -d -k 1 1 | grep $idisk |  awk '{print $3/1000}'` m/s"
		        diskwrite="`iostat -d -k 1 1 | grep $idisk |  awk '{print $4/1000}'` m/s"
			echo $idisk | grep 'nvme' &amp;&gt; /dev/null
			if &#91; $? -eq 0 ];then
		                echo -e "Disk IO (/dev/$idisk):\t\t\t\t \033&#91;1m$diskread\033&#91;0m (Read)\t\033&#91;1m$diskwrite\033&#91;0m (Write)"
		        else
		                echo -e "Disk IO (/dev/$idisk):\t\t\t\t \033&#91;1m$diskread\033&#91;0m (Read)\t\033&#91;1m$diskwrite\033&#91;0m (Write)"
			fi
	        done

        fi

        echo -e "Complete Monitoring: \c"
        for i in {1..97}
        do
                echo -e "#\c"
                sleep 0.01
        done
        echo
        sleep $sleeptime

        let nowtime++
done

        echo -e "Terminal Monitoring: \c"
        for i in {1..97}
        do
                echo -e "#\c"
                sleep 0.01
        done

exit</code></pre>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
